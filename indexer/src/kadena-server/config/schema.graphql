scalar BigInt
scalar DateTime
scalar Decimal

# Guard for an account.
type Guard {
    keys: [String!]!
    predicate: String!
}

# Queries for retrieving data
type Query {
    # Retrieve a block by hash.
    block(hash: String!): Block
}

# The Block type which implements the Node interface
type Block implements Node {
    id: ID! # Required by the Node interface
    hash: String!
    chainId: BigInt
    creationTime: DateTime!
    difficulty: BigInt
    events(
        after: String
        before: String
        first: Int
        last: Int
    ): BlockEventsConnection!
    epoch: DateTime!
    flags: Decimal!
    height: BigInt!
    nonce: Decimal!
    payloadHash: String!
    weight: Decimal!
    target: Decimal!
    parent: Block

    minerAccount: FungibleChainAccount!
    neighbors: [BlockNeighbor!]!

    transactions(
        after: String
        before: String
        first: Int
        last: Int
    ): BlockTransactionsConnection!

    #   The proof of work hash.
    #   powHash: String!
}

# Interface representing a node with an ID
interface Node {
    id: ID!
}

# The neighbor of a block.
type BlockNeighbor {
    chainId: String!
    hash: String!
}

type BlockEventsConnection {
    edges: [BlockEventsConnectionEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type BlockEventsConnectionEdge {
    cursor: String!
    node: Event!
}

type PageInfo {
    endCursor: String
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
}

type Event implements Node {
    id: ID!
    name: String
    block: Block!
    chainId: BigInt!

    height: BigInt!
    moduleName: String!

    requestkey: String!
    parameters: String
    qualifiedName: String!

    transaction: Transaction

    # incrementedId: Int!
    # The order index of this event, in the case that there are multiple events in one transaction.
    # orderIndex: BigInt!
}

# A fungible specific chain-account.
type FungibleChainAccount implements Node {
    accountName: String!
    balance: Float!
    chainId: String!
    fungibleName: String!
    guard: Guard!
    id: ID!

    transactions(
        after: String
        before: String
        first: Int
        last: Int
    ): FungibleChainAccountTransactionsConnection!

    transfers(
        after: String
        before: String
        first: Int
        last: Int
    ): FungibleChainAccountTransfersConnection!

    # used as parameter for the `transactions` field
    hash: String!
}

type FungibleChainAccountTransactionsConnection {
    edges: [FungibleChainAccountTransactionsConnectionEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type FungibleChainAccountTransactionsConnectionEdge {
    cursor: String!
    node: Transaction!
}

type BlockTransactionsConnection {
    edges: [BlockTransactionsConnectionEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type BlockTransactionsConnectionEdge {
    cursor: String!
    node: Transaction!
}

type Transaction implements Node {
    id: ID!
    cmd: TransactionCommand!
    hash: String!
    # result: TransactionInfo! - TODO
    sigs: [TransactionSignature!]!
}

type TransactionCommand {
    meta: TransactionMeta!

    # The network id of the environment.
    networkId: String!
    nonce: String!
    payload: TransactionPayload!
    # signers: [Signer!]!
}

type TransactionMeta {
    chainId: BigInt!
    creationTime: DateTime!
    gasLimit: BigInt!
    gasPrice: Float!
    sender: String!
    ttl: BigInt!
}

union TransactionPayload = ContinuationPayload | ExecutionPayload

union TransactionInfo = TransactionMempoolInfo | TransactionResult

# List of capabilities associated with/installed by this signer.
type TransactionSignature {
    sig: String!
}

type ContinuationPayload {
    # The environment data made available to the transaction. Formatted as raw JSON.
    data: String!
    # A unique id when a pact (defpact) is initiated. See the "Pact execution scope and pact-id" explanation in the docs for more information.
    pactId: String
    # The proof provided to continue the cross-chain transaction.
    proof: String
    # Whether or not this transaction can be rolled back.
    rollback: Boolean
    # The step-number when this is an execution of a `defpact`, aka multi-step transaction.
    step: Int
}

# The payload of an exec transaction.
type ExecutionPayload {
    # The Pact expressions executed in this transaction when it is an `exec` transaction.
    code: String
    # The environment data made available to the transaction. Formatted as raw JSON.
    data: String!
}

# The mempool information
type TransactionMempoolInfo {
    # The status of the mempool.
    status: String
}

# The result of a transaction.
type TransactionResult {
    # The transaction result when it was successful. Formatted as raw JSON.
    badResult: String
    block: Block!

    # The JSON stringified continuation in the case that it is a continuation.
    continuation: String
    eventCount: BigInt

    # TODO
    # events(
    #     after: String
    #     before: String
    #     first: Int
    #     last: Int
    # ): TransactionResultEventsConnection!
    # gas: BigInt!

    # The transaction result when it was successful. Formatted as raw JSON.
    goodResult: String

    # The height of the block this transaction belongs to.
    height: BigInt!

    # Identifier to retrieve the logs for the execution of the transaction.
    logs: String
    metadata: String
    transactionId: BigInt

    # TODO
    # transfers(
    #     after: String
    #     before: String
    #     first: Int
    #     last: Int
    # ): TransactionResultTransfersConnection!
}

# A signer for a specific transaction.
type Signer implements Node {
    # The signer for the gas.
    address: String
    id: ID!
    orderIndex: Int
    pubkey: String!

    # The signature scheme that was used to sign.
    scheme: String

    # clist: [TransactionCapability!]! - TODO-KADENA
}

type FungibleChainAccountTransfersConnection {
    edges: [FungibleChainAccountTransfersConnectionEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type FungibleChainAccountTransfersConnectionEdge {
    cursor: String!
    node: Transfer!
}

type Transfer implements Node {
    amount: Decimal!
    block: Block!
    blockHash: String!
    chainId: BigInt!
    creationTime: DateTime!

    # The counterpart of the crosschain-transfer. `null` when it is not a cross-chain-transfer.
    crossChainTransfer: Transfer
    height: BigInt!
    id: ID!
    moduleHash: String!
    moduleName: String!

    # The order of the transfer when it is a `defpact` (multi-step transaction) execution.
    orderIndex: BigInt!
    receiverAccount: String!
    requestKey: String!
    senderAccount: String!

    # The transaction that initiated this transfer.
    transaction: Transaction
}
